generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                       String              @id @default(uuid())
  createdAt                DateTime            @default(now())
  updatedAt                DateTime            @updatedAt
  email                    String              @unique
  lastName                 String
  role                     UserRole?
  firstName                String
  profileImage             String?
  dob                      DateTime?
  phoneNumber              String?
  stripeCustomerId         String?
  stripeSubscriptionId     String?
  currentLocation          Json?
  serviceArea              Json?
  stripeSubscriptionPlan   SubscriptionPlan?
  stripeSubscriptionStatus SubscriptionStatus?
  documentsUrl             String[]
  bookings                 Booking[]
  ChatUser                 ChatUser[]
  mechanic                 Mechanic?
  Message                  Message[]
  chatMessages             Message[]           @relation("UserMessages")
  pushSubscriptions        PushSubscription[]
  reviews                  Review[]
  serviceRequests          ServiceRequest[]
  Vehicle                  Vehicle[]
}

model Mechanic {
  id                  String            @id @default(uuid())
  userId              String            @unique
  bio                 String?
  rating              Float?
  bannerImage         String?
  driversLicenseId    String?
  merchantDocumentUrl String?
  availability        Json?
  isAvailable         Boolean           @default(false)
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt
  servicesOffered     ServiceType[]
  bookings            Booking[]
  earnings            Earning[]
  user                User              @relation(fields: [userId], references: [id])
  services            MechanicService[]
  ServiceOffer        ServiceOffer[]
  serviceRequests     ServiceRequest[]
}

model Vehicle {
  id           String  @id @default(uuid())
  make         String
  model        String
  year         Int
  licensePlate String?
  userId       String
  User         User    @relation(fields: [userId], references: [id])
}

model ServiceRequest {
  id             String         @id
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  clientId       String
  mechanicId     String?
  serviceType    ServiceType    @default(DIAGNOSTIC)
  status         ServiceStatus
  location       Json
  description    String?
  paymentHoldId  String?
  completionCode String?
  paymentId      String?
  offerExpiry    DateTime?
  offerNote      String?
  offeredPrice   Float?
  review         Review?
  offers         ServiceOffer[]
  client         User           @relation(fields: [clientId], references: [id])
  mechanic       Mechanic?      @relation(fields: [mechanicId], references: [id])
  payment        Payment?       @relation(fields: [paymentId], references: [id])
}

model Review {
  id               String         @id @default(uuid())
  serviceRequestId String         @unique
  clientId         String
  rating           Int
  comment          String?
  createdAt        DateTime       @default(now())
  client           User           @relation(fields: [clientId], references: [id])
  serviceRequest   ServiceRequest @relation(fields: [serviceRequestId], references: [id])
}

model Earning {
  id               String   @id @default(uuid())
  mechanicId       String
  amount           Float
  serviceRequestId String
  createdAt        DateTime @default(now())
  mechanic         Mechanic @relation(fields: [mechanicId], references: [id])
}

model Chat {
  id         Int        @id @default(autoincrement())
  customerId     String
  mechanicId String
  // createdAt  DateTime @default(now())
  // updatedAt  DateTime @updatedAt
  users      ChatUser[]
  messages   Message[]

  @@unique([customerId, mechanicId]) // Ensures unique chats between user and mechanic
}

model ChatUser {
  id     String @id @default(uuid())
  chatId Int
  userId String
  chat   Chat   @relation(fields: [chatId], references: [id])
  user   User   @relation(fields: [userId], references: [id])

  @@unique([chatId, userId])
}

model Message {
  id       Int    @id @default(autoincrement())
  chatId   Int
  authorId String
  content  String
  userId   String
  author   User   @relation(fields: [authorId], references: [id])
  chat     Chat   @relation(fields: [chatId], references: [id])
  user     User   @relation("UserMessages", fields: [userId], references: [id])
}

model Lead {
  id          String    @id @default(uuid())
  name        String?
  email       String
  phone       String?
  message     String?
  createdAt   DateTime  @default(now())
  responded   Boolean   @default(false)
  respondedAt DateTime?
}

model PushSubscription {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  userId    String
  endpoint  String   @unique
  p256dh    String
  auth      String
  user      User     @relation(fields: [userId], references: [id])
}

model Service {
  id          String            @id @default(cuid())
  type        ServiceType
  name        String
  description String
  price       Float
  duration    Int
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  bookings    Booking[]
  mechanics   MechanicService[]
}

model MechanicService {
  id         String   @id @default(cuid())
  mechanicId String
  serviceId  String
  price      Float
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  mechanic   Mechanic @relation(fields: [mechanicId], references: [id])
  service    Service  @relation(fields: [serviceId], references: [id])

  @@unique([mechanicId, serviceId])
}

model Booking {
  id             String        @id @default(cuid())
  customerId     String
  mechanicId     String
  serviceId      String
  scheduledStart DateTime
  scheduledEnd   DateTime
  status         BookingStatus @default(PENDING)
  totalPrice     Float
  notes          String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  customer       User          @relation(fields: [customerId], references: [id])
  mechanic       Mechanic      @relation(fields: [mechanicId], references: [id])
  service        Service       @relation(fields: [serviceId], references: [id])
  payment        Payment?
}

model Payment {
  id             String           @id @default(cuid())
  bookingId      String           @unique
  paymentMethod  String
  paymentStatus  String
  amount         Float
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  booking        Booking          @relation(fields: [bookingId], references: [id])
  ServiceRequest ServiceRequest[]
}

model ServiceOffer {
  id               String         @id @default(cuid())
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  mechanicId       String
  serviceRequestId String
  price            Float
  note             String?
  status           OfferStatus    @default(PENDING)
  expiresAt        DateTime?
  mechanic         Mechanic       @relation(fields: [mechanicId], references: [id])
  serviceRequest   ServiceRequest @relation(fields: [serviceRequestId], references: [id])
}

enum UserRole {
  Customer
  Mechanic
}

enum ServiceStatus {
  REQUESTED
  ACCEPTED
  IN_PROGRESS
  COMPLETED
  OFFERED
}

enum SubscriptionPlan {
  BASIC
  PREMIUM
  PRO
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  UNPAID
}

enum ServiceType {
  OIL_CHANGE
  BRAKE_REPAIR
  TIRE_SERVICE
  ENGINE_REPAIR
  DIAGNOSTIC
  BATTERY_SERVICE
  AC_SERVICE
  GENERAL_MAINTENANCE
}

enum BookingStatus {
  PENDING
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum OfferStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
  REJECTED
}
